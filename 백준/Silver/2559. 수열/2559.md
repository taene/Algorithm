### 틀린 풀이와 이유
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, K;
    cin >> N >> K;
    vector<pair<int, int>> v(N);

    for (int i = 0; i < N; ++i)
    {
        int tmp;
        cin >> tmp;

        for (int j = 0; j <= i; ++j)
        {
            if (v[j].second < K)
            {
                v[j].first += tmp;
                v[j].second++;
            }
        }
    }

    int ret = 0;
    for (auto it : v)
    {
        ret = max(ret, it.first);
    }
    cout << ret;

    return 0;
}
```
- N의 범위가 10만까진데, 해당 코드의 2중 for문은 10만*10만 = 100억의 연산을 하고있음
- 근데 이 문제는 시간제한이 1초임 (1초 = 대략 1억)
- 시간초과로 틀린 오답!

<br/>

### 슬라이딩 윈도우로 푼 풀이
```cpp

#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k;
	cin >> n >> k;

	vector<int> degree(n);
	vector<int> sum(n - k + 1, 0);
	for (int i = 0; i < n; i++)
	{
		cin >> degree[i];
	}

	// k == n 일때를 따로 빼서 빠르게 답을 구함. 생략가능
	if (k == n)
	{
		int sum = 0;
		for (int i = 0; i < degree.size(); i++)
		{
			sum += degree[i];
		}
		cout << sum;
	}
	else
	{
		int start = 0;
		int end = start + k;
		while (end <= degree.size())
		{
			for (int z = start; z < end; z++)
			{
				sum[start] += degree[z];
			}
			start++;
			end = start + k;
		}

		// max = k * degree (k < 100,000 , degree >= -100)
		int max = -10000000;
		for (int p = 0; p < sum.size(); p++)
		{
			if (max < sum[p])
				max = sum[p];
		}
		cout << max;
	}

	return 0;
}

```
- 슬라이딩 윈도우로 풀때 주의할 점: 초반에 k==n 일 때를 조기 처리하지 않으면 시간초과 남

</br>

### 누적합으로 푼 풀이
```cpp

#include <iostream>
using namespace std;

int n, k, temp;
int sum[100001];
int mx = -10000000;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n >> k;

	for (int i = 1; i <= n; i++)
	{
		cin >> temp;
		sum[i] = sum[i - 1] + temp;
	}

	for (int i = k; i <= n; i++)
	{
		mx = max(mx, sum[i] - sum[i - k]);
	}
	cout << mx;

	return 0;
}
```
