### 오답 풀이
```cpp
#include <iostream>
#include <map>
#include <vector>

using namespace std;

int main(int argc, char* argv[])
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    map<int, int> mpA;
    map<int, int> mpB;
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; ++i)
    {
        int temp;
        cin >> temp;
        mpA[temp]++;
    }
    for (int i = 0; i < m; ++i)
    {
        int temp;
        cin >> temp;
        mpB[temp]++;
    }

    int cnt = 0;
    for (auto& a : mpA)
    {
        for (auto& b : mpB)
        {
            if (a.first == b.first)
            {
                a.second--;
                b.second--;
                break;
            }
        }
    }
    for (auto& a : mpA)
    {
        if (a.second > 0) cnt++;
    }
    for (auto& b : mpB)
    {
        if (b.second > 0) cnt++;
    }
    cout << cnt;

    return 0;
}
```
---
## 학습 키워드

  * 시간 복잡도 (Time Complexity)
  * 알고리즘 시간 초과 (Time Limit Exceeded)
  * 대칭 차집합 (Symmetric Difference)
  * std::map
  * $O(N \times M)$
  * $O(N \log N)$

## 학습 내용

### 배운 개념 요약

'대칭 차집합' 문제를 풀이하는 과정에서 `std::map`을 사용했음에도 불구하고 '시간 초과'가 발생했다. 제출한 코드의 시간 복잡도를 분석하여 원인을 파악한다.

핵심 원인은 **`std::map`의 $O(\log N)$ 탐색 기능을 사용하지 않고, $O(N \times M)$의 중첩 반복문을 사용하여 교집합을 탐색**했기 때문이다.

1.  **`std::map` 삽입 복잡도:** `map`은 균형 이진 탐색 트리(레드-블랙 트리)로 구현된다. $N$개의 원소를 삽입하는 데 걸리는 총 시간은 $O(\log 1 + \log 2 + ... + \log N) = O(N \log N)$이다. $M$개의 원소를 삽입하는 데는 $O(M \log M)$이 소요된다. $N, M$이 200,000일 때 이 연산은 충분히 빠르다.
2.  **교집합 탐색 복잡도 (병목 구간):**
      * `mpA`의 모든 원소를 순회하는 외부 루프 ($O(N)$)
      * `mpA`의 **각 원소마다** `mpB`의 **모든 원소**를 순회하는 내부 루프 ($O(M)$)
      * `map`을 사용했음에도 불구하고, `map`의 `find` 메서드( $O(\log M)$ )를 사용하지 않고 전체를 순회(iterate)했다.
      * 따라서 이 중첩 루프 구간의 시간 복잡도는 $O(N \times M)$이다.
3.  **최종 시간 복잡도:** $O(N \log N + M \log M + N \times M)$에서 가장 지배적인 항은 $O(N \times M)$이다.
4.  **결론:** $N$과 $M$이 최대 200,000이므로, $N \times M$은 최악의 경우 약 $400$억 ($4 \times 10^{10}$)에 가까운 연산을 수행한다. 일반적인 C++ 채점 환경이 1초에 약 1억\~2억 회의 연산을 처리하는 것을 감안할 때, $O(N \times M)$ 풀이는 명백히 시간 초과를 유발한다.

### 구현 과정

제출한 코드의 시간 복잡도를 단계별로 분석한다.

1.  **입력 및 `mpA` 구성** ( $O(N \log N)$ )
    ```cpp
    map<int, int> mpA;
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; ++i)
    {
        int temp;
        cin >> temp;
        mpA[temp]++; // 삽입 연산: O(log N)
    }
    // 총 O(N log N)
    ```
2.  **`mpB` 구성** ( $O(M \log M)$ )
    ```cpp
    map<int, int> mpB;
    for (int i = 0; i < m; ++i)
    {
        int temp;
        cin >> temp;
        mpB[temp]++; // 삽입 연산: O(log M)
    }
    // 총 O(M log M)
    ```
3.  **교집합 탐색** ( **$O(N \times M)$** ) - **시간 초과 원인**
    ```cpp
    for (auto& a : mpA) // 외부 루프: 최악 N회
    {
        for (auto& b : mpB) // 내부 루프: 최악 M회
        {
            if (a.first == b.first)
            {
                a.second--;
                b.second--;
                break; // 교집합을 찾으면 내부 루프 탈출
            }
        }
    }
    // 최악의 경우 (교집합이 없거나 뒤에 몰린 경우) N * M 번 비교
    // 총 O(N * M)
    ```
4.  **결과 카운트** ( $O(N + M)$ )
    ```cpp
    int cnt = 0;
    for (auto& a : mpA) // O(N)
    {
        if (a.second > 0) cnt++;
    }
    for (auto& b : mpB) // O(M)
    {
        if (b.second > 0) cnt++;
    }
    // 총 O(N + M) (정확히는 고유 원소의 개수 N', M')
    ```
5.  **최종 분석**
      * 전체 시간 복잡도 = $O(N \log N) + O(M \log M) + O(N \times M) + O(N + M)$
      * $N \times M$ 항이 다른 모든 항을 압도하므로, 최종 시간 복잡도는 $O(N \times M)$이다.

## 느낀점

  * `std::map`과 같은 효율적인 자료구조를 선택하는 것만으로는 충분하지 않다는 것을 깨달았다.
  * 자료구조의 장점을 활용하는 올바른 알고리즘을 적용하는 것이 중요하다. 이 경우, `map`의 $O(\log M)$ 시간 복잡도를 가진 `find` 연산을 사용해야 했다.
  * `mpA`를 순회하면서( $O(N)$ ) 각 원소 `a.first`가 `mpB`에 존재하는지 `mpB.find(a.first)` ( $O(\log M)$ )로 확인했다면, 교집합 탐색은 $O(N \log M)$만에 완료할 수 있었다.
  * 알고리즘 문제를 풀 때, 문제의 입력 제한( $N, M \le 200,000$ )을 보고 $O(N^2)$이나 $O(N \times M)$ 풀이는 불가능하며, 최소 $O(N \log N)$ 또는 $O(N)$ 수준의 풀이가 필요함을 예측하는 습관을 들여야 한다.
---
### 고친 풀이!!
- 시간복잡도: $O(N \log N + M \log M + N \log M + M \log N)$
```cpp
#include <iostream>
#include <map>
#include <vector>

using namespace std;

int main(int argc, char* argv[])
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    map<int, int> mpA;
    map<int, int> mpB;
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; ++i)
    {
        int temp;
        cin >> temp;
        mpA[temp]++;
    }
    for (int i = 0; i < m; ++i)
    {
        int temp;
        cin >> temp;
        mpB[temp]++;
    }

    int cnt = 0;
    for (auto& a : mpA)
    {
        if (mpB.find(a.first) == mpB.end())
        {
            cnt++;
        }
    }
    for (auto& b : mpB)
    {
        if (mpA.find(b.first) == mpA.end())
        {
            cnt++;
        }
    }
    cout << cnt;

    return 0;
}
```
