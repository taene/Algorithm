### 최근 풀이 260228
```cpp
#include <iostream>
#include <vector>
using namespace std;

int N,rootNode,eraseNode,ret;
vector<int> v[51];
bool visited[51];
void dfs(int n)
{
    int cnt = 0;
    visited[n]=true;
    
    for(int t: v[n])
    {
        if(!visited[t])
        {
            cnt++;
            dfs(t);
        }
    }
    
    if(cnt==0)
    {
        ret++;
        return;
    }
}

int main()
{
    cin>>N;
    for(int i=0; i<N; ++i)
    {
        int temp;
        cin>>temp;
        if(temp!=-1)
        {
            v[temp].push_back(i);
        }
        else
        {
            rootNode = i;
        }
    }
    
    cin>>eraseNode;
    visited[eraseNode] = true;
    
    if(rootNode!=eraseNode)
    {
        dfs(rootNode);
    }
    
    cout<<ret;
    
    return 0;
}
```

- 풀이 방식은 로직을 3개로 구분해서 생각하며 풀었다. (1. 입력을 토대로 트리를 만드는 로직, 2. 트리에서 노드를 제거하는 로직, 3. 리프 노드의 개수를 구하는 로직)
1. 입력을 토대로 트리를 만드는 로직
   - 2차원 벡터 배열로 단방향 트리를 만들자!
2. 트리에서 노드를 제거하는 로직
   - erase()로 복잡하게 제거하는것 보다, visited[]로 방문 처리를 해서 간편하게 해당 노드를 건너뛰자!
3. 리프 노드의 개수를 구하는 로직
   - 여기가 관건이었는데... 처음엔 단순히 vector가 비어있는지만 체크해서 리프노드 개수를 ret++ 해줬었다.
   - 근데 이때 vector에 요소가 딱 한개 있지만, 해당 요소가 eraseNode 여서 방문 처리가 되어있을 경우 리프노드임을 감지하지 못했다.
   - 이렇게 자식이 있었지만 삭제돼서 결과적으로 리프 노드가 된 예외 사항을 놓치게 됐었다.
   - 이런 동적 계층 구조 변화를 처리할 때, 단순히 플래그 하나로 처리하려는 것 보다는 유효한 자식의 개수를 확인하면 된다!
- 기존 로직: `v[n].empty()`일 때만 리프 노드로 간주했음. 
- 발생한 예외: `v[n]`에 자식 `eraseNode`가 들어있어서 `empty()`는 `false`지만, 실제로 방문할 수 있는 자식은 없어서 논리적으로 리프 노드가 된 상황
