## Heap
#### 1. 느슨하게 정렬된 **완전 이진 트리**
- 배열처럼 모든 원소가 완벽하게 정렬된 상태는 아니지만, 가장 작은 값(or 가장 큰 값)은 항상 쉽게 찾을 수 있도록 특정 규칙에 따라 정렬되어 있다.
- 최소 힙(Min-Heap): 부모 노드의 값이 자식 노드의 값보다 항상 작거나 같다. Root Node에는 항상 최솟값이 위치한다.
- 최대 힙(Max-Heap): 부모 노드의 값이 자식 노드의 값보다 항상 크거나 같다. Root Node에는 항상 최댓값이 위치한다.

#### 2. 최소 힙의 핵심 규칙 2가지
- 힙 속성(Heap Property)
  - **모든 부모 노드는 자식 노드보다 작거나 같은 값을 가진다**
- 모양 속성(Shape Property)
  - **힙은 항상 완전 이진 트리(Complete Binary Tree)형태를 유지해야 한다**

#### 3. 배열로 힙 구현(내부 동작)
- 힙의 개념은 트리지만, 빈 공간 없이 데이터를 꽉 채워 저장할 수 있는 배열로 구현하는 것이 메모리 효율면에서 좋다.
- 배열의 `i`번째 인덱스에 있는 노드:
  - 부모 노드 인덱스: `(i - 1) / 2`
  - 왼쪽 자식 노드 인덱스: `2 * i + 1`
  - 오른쪽 자식 노드 인덱스: `2 * i + 2`

#### 4. 힙의 핵심 연산: 삽입(Insert)과 삭제(Delete)
- 최소 힙을 기준으로 설명
- 삽입(Insert): 새 원소를 힙에 추가하는 과정
  1. 일단 맨 끝에 원소 추가
  2. 부모와 비교해 위로 올리기: 만약 자식(새 원소)이 부모보다 작다면, 둘의 자리를 바꾼다.
  3. 반복: 힙 속성을 만족할 때까지(or 루트에 도달할 때까지) 반복한다.

- 삭제(Delete): 루트 노드(최솟값or최댓값)을 삭제하는 연산
  1. 루트 제거 및 마지막 원소 이동: 루트 노드(배열의 첫번째 원소)를 제거하고, 그 자리에 배열의 가장 마지막 원소를 놓는다.(모양 속성 유지)
  2. 자식과 비교하며 아래로 내리기: 새로운 루트가 된 원소를 두 자식 노드와 비교해서, 만약 자식 노드보다 크다면, **더 작은 값을 가진 자식**과 자리를 바꾼다.
  3. 반복: 힙 속성을 만족할 때까지(or 리프 노드에 도달할 때까지) 반복한다.
 
#### 5. 힙 주요 용도
- 우선순위 큐(Priority Queue): 힙의 가장 대표적인 활용 사례
  - AI 행동 결정: 여러 행동 후보 중 가장 우선순위가 높은 행동을 선택할 때
  - 이벤트 시스템: 발생 시간이 가장 빠른 이벤트를 먼저 처리하기 위해
  - A* 길찾기 알고리즘: '가장 비용이 적게 드는 노드'를 우선적으로 탐색할 때(Dijkstra 알고리즘 포함)
- 힙 정렬(HeapSort): 힙을 이용한 효율적인 정렬 알고리즘
- Top-K 문제: 스트리밍 데이터에서 가장 크거나 작은 K개의 원소를 유지할 때

<br/>

### C++ STL Priority Queue
```cpp
priority_queue<int> max_heap;  // priority_queue<int, vector<int>, less<int>> pq;
priority_queue<int, vector<int>, greater<int>> min_heap;
```
