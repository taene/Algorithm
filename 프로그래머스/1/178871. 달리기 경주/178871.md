### 첫번째 풀이
```cpp
#include <string>
#include <vector>
#include <map>
using namespace std;

vector<string> solution(vector<string> players, vector<string> callings)
{
    vector<string> answer;
    map<int, string> m1;
    map<string, int> m2;
    
    for(int i=0; i<players.size(); i++)
    {
        m1[i] = players[i];
        m2[players[i]] = i;
    }
    
    for(int i=0; i<callings.size(); i++)
    {
        int cur_idx = m2[callings[i]];
        string change = m1[cur_idx - 1];
        
        m1[cur_idx - 1] = callings[i];
        m1[cur_idx] = change;
        
        m2[callings[i]] = cur_idx - 1;
        m2[change] = cur_idx;
    }
    
    for(const auto& c : m1) 
        answer.push_back(c.second);
    
    return answer;
}
```

<br/>

## 성능 병목 지점: std::map vs std::unordered_map
> 가장 큰 성능 병목은 std::map을 사용한 것이다.
- std::map:
  - 구조: 레드-블랙 트리(Red-Black Tree)라는 균형 이진 탐색 트리로 구현된다.
  - 특징: Key를 기준으로 항상 정렬된 상태를 유지한다.
  - 시간 복잡도: 원소 탐색, 삽입, 삭제에 $O(\log N)$이 걸린다. 선수가 50,000명이라면 log₂(50000)은 약 15.6이므로, 한 번의 탐색에 15~16단계의 연산이 필요하다. callings가 1,000,000번 호출되면 이 차이는 매우 커진다.
- std::unordered_map:
  - 구조: 해시 테이블(Hash Table)로 구현된다.
  - 특징: Key를 해싱하여 값을 저장하므로 정렬되지 않는다.
  - 시간 복잡도: 원소 탐색, 삽입, 삭제가 평균적으로 **O(1)**이다. 정렬이 필요 없는 이 문제에서는 std::map보다 월등히 빠르다.
- 언리얼 엔진의 TMap 역시 해시 테이블 기반이다. 실시간 렌더링과 빠른 로직 처리가 생명인 게임 엔진에서는 $O(\log N)$도 느리다고 판단될 때가 많다. 특정 데이터를 이름이나 ID로 즉시 찾아야 할 때는 거의 항상 해시 맵을 사용하는 것이 표준이다.

<br/>

## 코드 리팩토링: map<int, string> 제거
- 코드에서 m1(map<int, string>)과 m2(map<string, int>) 두 개의 맵을 사용했다.
  - m2는 이름으로 등수를 빠르게 찾기 위해 필수적이지만, m1은 사실상 원본 players 벡터와 같은 역할을 하고 있다.
  - 불필요한 자료구조를 하나 더 사용하는 셈이다.
- 문제점
  - 메모리 낭비: players 벡터와 거의 동일한 데이터를 map에 중복 저장한다.
  - 코드 복잡도 증가: players 벡터 대신 m1 맵을 업데이트해야 하므로 코드가 더 복잡해진다.
  - 불필요한 마지막 루프: 최종 순위를 만들기 위해 m1을 다시 순회하여 answer 벡터를 생성해야 한다.
- 개선 방안: players 벡터를 직접 수정하기! players 벡터 자체가 현재 등수 정보를 담고 있는 자료구조이므로, 추월이 일어날 때마다 이 벡터의 원소 두 개를 직접 교환(swap)하면 된다.

<br/>

## 수정된 코드
- 위 두 가지 사항을 반영하여 코드를 수정했다.
- std::map을 std::unordered_map으로 변경하여 조회 성능을 `O(1)`로 만들었다.
- 불필요한 m1 맵을 제거하고 players 벡터를 직접 수정하여 메모리 사용량과 코드 복잡도를 줄였다.
- 변수명을 더 명확하게 변경하고, callings 순회 시 범위 기반 for문을 사용했다.

### 최종 풀이
```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

vector<string> solution(vector<string> players, vector<string> callings)
{
    unordered_map<string, int> playerPosition;
    for (int i = 0; i < players.size(); ++i)
    {
        playerPosition[players[i]] = i;
    }

    for (const string& cp : callings)
    {
        int curIndex = playerPosition[cp];
        string change = players[curIndex - 1];

        playerPosition[cp] = curIndex - 1;
        playerPosition[change] = curIndex;
        
        swap(players[curIndex], players[curIndex - 1]);
    }

    return players;
}
```

### 요약

| 구분 | 기존 코드 | 수정된 코드 | 개선 효과 |
| :--- | :--- | :--- | :--- |
| **핵심 자료구조** | `map<string, int>`, `map<int, string>` | `unordered_map<string, int>`, `vector<string>` | **성능 향상** 및 **메모리 최적화** |
| **조회 시간 복잡도** | $O(log N)$ | $O(1)$ | 대규모 데이터에서 월등히 빠름 |
| **공간 복잡도** | $O(N)$ (Vector + Map 2개) | $O(N)$ (Vector + Map 1개) | 중복 데이터 제거로 효율성 증가 |
| **코드 구조** | 랭킹 맵(`m1`)을 별도 관리 | `players` 벡터 직접 수정 | 코드 간소화, 가독성 및 유지보수성 향상 |
